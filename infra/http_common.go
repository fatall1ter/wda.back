package infra

import (
	"context"
	b64 "encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"regexp"
	"strconv"
	"time"

	"git.countmax.ru/countmax/wda.back/internal/session"
	"github.com/labstack/echo/v4"
)

const (
	vueURL                string = "web/index.html"
	sessCookieID          string = "cdapi_session_id"
	kratosSessCookieID    string = "session_token"
	oryKratosSessCookieID string = "ory_kratos_session"
	PAGESIZE              int    = 10
	XUserID               string = "X-User-ID"
	XUserEMAIL            string = "X-User-EMAIL"
	XUserPermission       string = "X-User-Permissions"
)

func (s *Server) customHTTPErrorHandler(err error, c echo.Context) {
	// routes := s.mux.Routes()
	// for _, route := range routes {
	// 	if route.Path == c.Path() {
	// 		return
	// 	}
	// }
	if err := c.File(vueURL); err != nil {
		c.Logger().Error(err)
	}
}

// customHTTPLogger - middleware of logger and metric duration
func (s *Server) customHTTPLogger(next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		start := time.Now()
		if err := next(c); err != nil {
			c.Error(err)
		}
		rID := c.Response().Header().Get("x-request-id")
		code := c.Response().Status
		uri := c.Request().URL.EscapedPath()
		query := c.Request().URL.Query().Encode()
		httplog := s.log.With(
			"method", c.Request().Method,
			"proto", c.Request().Proto,
			"remote", c.Request().RemoteAddr,
			"url", uri,
			"query", query,
			"code", code,
			"size", c.Response().Size,
			"duration", time.Since(start).String(),
			requestIDName, rID)
		host, err := os.Hostname()
		if err != nil {
			s.log.Warnf("define hostname error %s, set to localhost", err)
			host = "localhost"
		}
		switch {
		case code < 300:
			httplog.Infof("%s", host)
		case code > 300 && code < 400:
			httplog.Warnf("%s", host)
		case code >= 400:
			httplog.Errorf("%s", host)
		}
		s.mAPI.WithLabelValues(uri, strconv.Itoa(code), c.Request().Method).
			Observe(time.Since(start).Seconds())
		return nil
	}
}

// checkSession - middleware of logger and metric duration
func (s *Server) checkSession(next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		s.log.Debug("call checkSession")
		rawSessionID, sessionSource := s.getSessionID(c)
		sessID := &session.ID{ID: rawSessionID, Src: sessionSource}
		session := s.sess.Check(sessID)
		if session == nil {
			s.log.Warnf("session not found by id=%+v, redirect to login page", sessID)
			return c.NoContent(http.StatusUnauthorized)
		}
		// set user attribute
		c.Request().Header.Add(XUserID, session.UID)
		c.Request().Header.Add(XUserEMAIL, session.Login)
		// get permissions
		perms := s.getPermissions(c.Request().Context(), session)
		s.log.Debugf("got permissions %s", perms)
		if perms != "" {
			c.Request().Header.Add(XUserPermission, perms)
		}

		if err := next(c); err != nil {
			c.Error(err)
		}
		return nil
	}
}

func (s *Server) getPermissions(ctx context.Context, session *session.Session) string {
	if s.perm == nil {
		return ""
	}
	const filter string = "data.counting"
	subject := session.UserDomain + ":subjects:" + session.UID
	perm, err := s.perm.Find(ctx, subject, filter)
	if err != nil {
		s.log.Errorf("find permissions for %s with filter %s, failed %s", subject, filter, err)
		return ""
	}
	s.log.Debugf("got permissions %+v, makes base64 string", perm)
	bts, err := json.Marshal(perm)
	if err != nil {
		s.log.Errorf("marshal permissions failed %s", err)
		return ""
	}
	return b64.StdEncoding.EncodeToString(bts)
}

var reBearer = regexp.MustCompile(`(?m)([Bb]earer)\s(.*)`)

func (s *Server) getSessionID(c echo.Context) (string, session.TokenSource) {
	cookie1, err := c.Cookie(sessCookieID)
	if err == nil {
		s.log.Debugf("extract cookie %s success", sessCookieID)
		return cookie1.Value, session.FromCookie
	}
	cookie2, err := c.Cookie(kratosSessCookieID)
	if err == nil {
		s.log.Debugf("extract cookie %s success", kratosSessCookieID)
		return cookie2.Value, session.FromCookie
	}
	cookie3, err := c.Cookie(oryKratosSessCookieID)
	if err == nil {
		s.log.Debugf("extract cookie %s success", oryKratosSessCookieID)
		return cookie3.Value, session.FromCookie
	}
	ah := c.Request().Header.Get("Authorization")
	if ah == "" {
		return "", session.FromBearer
	}
	// Bearer tokenvalue
	tokenParts := reBearer.FindStringSubmatch(ah)
	tokenPartsLen := len(tokenParts)
	if tokenPartsLen == 0 {
		return "", session.FromBearer
	}
	return tokenParts[tokenPartsLen-1], session.FromBearer
}

// Generated by https://quicktype.io

// apiHealthCheck returk 200 ok if repository is connected
// @Summary healthcheck service eq repository connected
// @Tags health
// @Success 200 {object} infra.SuccessResponse
// @Failure 500 {object} infra.ErrResponse
// @Router /health [get]
func (s *Server) apiHealthCheck(c echo.Context) error {
	err := s.healthCheck()
	if err != nil {
		return c.JSON(http.StatusInternalServerError, ErrServerInternal(err))
	}
	return c.JSON(http.StatusOK, OkStatus("OK"))
}

// metrics return prometheus metrics
// @Summary prometheus metrics
// @Tags health
// @Success 200
// @Router /metrics [get]
// func (s *Server) metrics(c echo.Context) error {
// 	return c.Redirect(http.StatusPermanentRedirect, "/metrics")
// }

// SuccessResponse structure for json response success results
type SuccessResponse struct {
	Message        string `json:"message"`  // text of message
	HTTPStatusCode int    `json:"httpcode"` // http response status code
	StatusText     string `json:"status"`   // user-level status message
}

// OkStatus wrapper HTTP 200 OK response
func OkStatus(message string) SuccessResponse {
	return SuccessResponse{
		Message:        message,
		HTTPStatusCode: http.StatusOK,
		StatusText:     http.StatusText(http.StatusOK),
	}
}

// CreatedStatus wrapper HTTP 201 Create response
func CreatedStatus(message string) SuccessResponse {
	return SuccessResponse{
		Message:        message,
		HTTPStatusCode: http.StatusCreated,
		StatusText:     http.StatusText(http.StatusCreated),
	}
}

// HTTPError represents an error that occurred while handling a request.
type HTTPError struct {
	Code     int         `json:"-"`
	Message  interface{} `json:"message"`
	Internal error       `json:"-"` // Stores the error returned by an external dependency
}

// Metadata - metadata, page, limit, offset... etc...
type Metadata struct {
	ResultSet ResultSet `json:"result_set"`
}

// ResultSet - values total, limit....
type ResultSet struct {
	Count  int64 `json:"count"`
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
	Total  int64 `json:"total"`
}

// ErrResponse structure for common response with some error
type ErrResponse struct {
	Err            error  `json:"-"`               // low-level runtime error
	HTTPStatusCode int    `json:"-"`               // http response status code
	StatusText     string `json:"status"`          // user-level status message
	AppCode        int64  `json:"code,omitempty"`  // application-specific error code
	ErrorText      string `json:"error,omitempty"` // application-level error message, for debugging
}

// ErrInvalidRequest - wrapper for make err structure
func ErrInvalidRequest(err error) ErrResponse {
	return ErrResponse{
		Err:            err,
		HTTPStatusCode: http.StatusBadRequest,
		StatusText:     http.StatusText(http.StatusBadRequest),
		ErrorText:      fmt.Sprintf("%v", err),
	}
}

// ErrServerInternal - wrapper for make err structure
func ErrServerInternal(err error) ErrResponse {
	return ErrResponse{
		Err:            err,
		HTTPStatusCode: http.StatusInternalServerError,
		StatusText:     http.StatusText(http.StatusInternalServerError),
		ErrorText:      fmt.Sprintf("%v", err),
	}
}

// ErrNotAuthorized - wrapper for make err structure
func ErrNotAuthorized(err error) ErrResponse {
	return ErrResponse{
		Err:            err,
		HTTPStatusCode: http.StatusUnauthorized,
		StatusText:     http.StatusText(http.StatusUnauthorized),
		ErrorText:      fmt.Sprintf("%v", err),
	}
}
